
nl_main:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000438  00001800  00001800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00001c38  000004cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000df  00800060  00800060  000004cc  2**0
                  ALLOC
  3 .stab         000015a8  00000000  00000000  000004cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000131c  00000000  00000000  00001a74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00002d90  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00001800 <__vectors>:
    1800:	12 c0       	rjmp	.+36     	; 0x1826 <__ctors_end>
    1802:	21 c0       	rjmp	.+66     	; 0x1846 <__bad_interrupt>
    1804:	20 c0       	rjmp	.+64     	; 0x1846 <__bad_interrupt>
    1806:	1f c0       	rjmp	.+62     	; 0x1846 <__bad_interrupt>
    1808:	1e c0       	rjmp	.+60     	; 0x1846 <__bad_interrupt>
    180a:	1d c0       	rjmp	.+58     	; 0x1846 <__bad_interrupt>
    180c:	1c c0       	rjmp	.+56     	; 0x1846 <__bad_interrupt>
    180e:	1b c0       	rjmp	.+54     	; 0x1846 <__bad_interrupt>
    1810:	1a c0       	rjmp	.+52     	; 0x1846 <__bad_interrupt>
    1812:	19 c0       	rjmp	.+50     	; 0x1846 <__bad_interrupt>
    1814:	18 c0       	rjmp	.+48     	; 0x1846 <__bad_interrupt>
    1816:	17 c0       	rjmp	.+46     	; 0x1846 <__bad_interrupt>
    1818:	16 c0       	rjmp	.+44     	; 0x1846 <__bad_interrupt>
    181a:	15 c0       	rjmp	.+42     	; 0x1846 <__bad_interrupt>
    181c:	14 c0       	rjmp	.+40     	; 0x1846 <__bad_interrupt>
    181e:	13 c0       	rjmp	.+38     	; 0x1846 <__bad_interrupt>
    1820:	12 c0       	rjmp	.+36     	; 0x1846 <__bad_interrupt>
    1822:	11 c0       	rjmp	.+34     	; 0x1846 <__bad_interrupt>
    1824:	10 c0       	rjmp	.+32     	; 0x1846 <__bad_interrupt>

00001826 <__ctors_end>:
    1826:	11 24       	eor	r1, r1
    1828:	1f be       	out	0x3f, r1	; 63
    182a:	cf e5       	ldi	r28, 0x5F	; 95
    182c:	d4 e0       	ldi	r29, 0x04	; 4
    182e:	de bf       	out	0x3e, r29	; 62
    1830:	cd bf       	out	0x3d, r28	; 61

00001832 <__do_clear_bss>:
    1832:	21 e0       	ldi	r18, 0x01	; 1
    1834:	a0 e6       	ldi	r26, 0x60	; 96
    1836:	b0 e0       	ldi	r27, 0x00	; 0
    1838:	01 c0       	rjmp	.+2      	; 0x183c <.do_clear_bss_start>

0000183a <.do_clear_bss_loop>:
    183a:	1d 92       	st	X+, r1

0000183c <.do_clear_bss_start>:
    183c:	af 33       	cpi	r26, 0x3F	; 63
    183e:	b2 07       	cpc	r27, r18
    1840:	e1 f7       	brne	.-8      	; 0x183a <.do_clear_bss_loop>
    1842:	a8 d1       	rcall	.+848    	; 0x1b94 <main>
    1844:	f7 c1       	rjmp	.+1006   	; 0x1c34 <_exit>

00001846 <__bad_interrupt>:
    1846:	dc cf       	rjmp	.-72     	; 0x1800 <__vectors>

00001848 <boot_program_page>:
static void (*app_ptr)(void) = (void *)0x0000;
static uint8_t myaddress[NL_ADDRESSSIZE];
static nl_config myconfig = {SPM_PAGESIZE, RFM12_RX_BUFFER_SIZE, NL_VERSION};

void boot_program_page (uint32_t page, uint8_t *buf)
{
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
	uint16_t i;
	uint8_t sreg;

	sreg = SREG;
    1850:	1f b7       	in	r17, 0x3f	; 63
	cli();
    1852:	f8 94       	cli

	page *= SPM_PAGESIZE;
    1854:	26 e0       	ldi	r18, 0x06	; 6
    1856:	66 0f       	add	r22, r22
    1858:	77 1f       	adc	r23, r23
    185a:	88 1f       	adc	r24, r24
    185c:	99 1f       	adc	r25, r25
    185e:	2a 95       	dec	r18
    1860:	d1 f7       	brne	.-12     	; 0x1856 <boot_program_page+0xe>

	eeprom_busy_wait ();
    1862:	e1 99       	sbic	0x1c, 1	; 28
    1864:	fe cf       	rjmp	.-4      	; 0x1862 <boot_program_page+0x1a>

	boot_page_erase (page);
    1866:	eb 01       	movw	r28, r22
    1868:	23 e0       	ldi	r18, 0x03	; 3
    186a:	fb 01       	movw	r30, r22
    186c:	20 93 57 00 	sts	0x0057, r18
    1870:	e8 95       	spm
	boot_spm_busy_wait ();      /* Wait until the memory is erased. */
    1872:	07 b6       	in	r0, 0x37	; 55
    1874:	00 fc       	sbrc	r0, 0
    1876:	fd cf       	rjmp	.-6      	; 0x1872 <boot_program_page+0x2a>
    1878:	da 01       	movw	r26, r20
    187a:	20 e0       	ldi	r18, 0x00	; 0
    187c:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		boot_page_fill (page + i, *((uint16_t *) (buf + i)));
    187e:	01 e0       	ldi	r16, 0x01	; 1
    1880:	4d 91       	ld	r20, X+
    1882:	5d 91       	ld	r21, X+
    1884:	f9 01       	movw	r30, r18
    1886:	ec 0f       	add	r30, r28
    1888:	fd 1f       	adc	r31, r29
    188a:	0a 01       	movw	r0, r20
    188c:	00 93 57 00 	sts	0x0057, r16
    1890:	e8 95       	spm
    1892:	11 24       	eor	r1, r1
	eeprom_busy_wait ();

	boot_page_erase (page);
	boot_spm_busy_wait ();      /* Wait until the memory is erased. */

	for (i=0; i<SPM_PAGESIZE; i+=2)
    1894:	2e 5f       	subi	r18, 0xFE	; 254
    1896:	3f 4f       	sbci	r19, 0xFF	; 255
    1898:	20 34       	cpi	r18, 0x40	; 64
    189a:	31 05       	cpc	r19, r1
    189c:	89 f7       	brne	.-30     	; 0x1880 <boot_program_page+0x38>
	{
		boot_page_fill (page + i, *((uint16_t *) (buf + i)));
	}

	boot_page_write (page);     // Store buffer in flash page.
    189e:	25 e0       	ldi	r18, 0x05	; 5
    18a0:	fb 01       	movw	r30, r22
    18a2:	20 93 57 00 	sts	0x0057, r18
    18a6:	e8 95       	spm
	boot_spm_busy_wait();       // Wait until the memory is written.
    18a8:	07 b6       	in	r0, 0x37	; 55
    18aa:	00 fc       	sbrc	r0, 0
    18ac:	fd cf       	rjmp	.-6      	; 0x18a8 <boot_program_page+0x60>

	/* re-enable flash */
	boot_rww_enable ();
    18ae:	81 e1       	ldi	r24, 0x11	; 17
    18b0:	80 93 57 00 	sts	0x0057, r24
    18b4:	e8 95       	spm

	// Re-enable interrupts (if they were ever enabled).
	SREG = sreg;
    18b6:	1f bf       	out	0x3f, r17	; 63
}
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	1f 91       	pop	r17
    18be:	0f 91       	pop	r16
    18c0:	08 95       	ret

000018c2 <spi_data>:
#if RFM12_SPI_SOFTWARE
/* @description Actual sending function to send raw data to the Module
 * @note do NOT call this function directly, unless you know what you're doing.
 */
static uint8_t spi_data(uint8_t c)
{
    18c2:	28 e0       	ldi	r18, 0x08	; 8
	uint8_t x, d=d;
	for(x=0;x<8;x++){
		if(c & 0x80){
    18c4:	87 ff       	sbrs	r24, 7
    18c6:	02 c0       	rjmp	.+4      	; 0x18cc <spi_data+0xa>
			PORT_MOSI |= (1<<BIT_MOSI);
    18c8:	c3 9a       	sbi	0x18, 3	; 24
    18ca:	01 c0       	rjmp	.+2      	; 0x18ce <spi_data+0xc>
		}else{
			PORT_MOSI &= ~(1<<BIT_MOSI);
    18cc:	c3 98       	cbi	0x18, 3	; 24
		}
		PORT_SCK |= (1<<BIT_SCK);
    18ce:	c5 9a       	sbi	0x18, 5	; 24
		d<<=1;
    18d0:	99 0f       	add	r25, r25
		if(PIN_MISO & (1<<BIT_MISO)){
    18d2:	b4 99       	sbic	0x16, 4	; 22
			d|=1;
    18d4:	91 60       	ori	r25, 0x01	; 1
		}
		PORT_SCK &= ~(1<<BIT_SCK);
    18d6:	c5 98       	cbi	0x18, 5	; 24
		c<<=1;
    18d8:	88 0f       	add	r24, r24
    18da:	21 50       	subi	r18, 0x01	; 1
 * @note do NOT call this function directly, unless you know what you're doing.
 */
static uint8_t spi_data(uint8_t c)
{
	uint8_t x, d=d;
	for(x=0;x<8;x++){
    18dc:	99 f7       	brne	.-26     	; 0x18c4 <spi_data+0x2>
		}
		PORT_SCK &= ~(1<<BIT_SCK);
		c<<=1;
	}
	return d;
}
    18de:	89 2f       	mov	r24, r25
    18e0:	08 95       	ret

000018e2 <rfm12_data>:


//non-inlined version of rfm12_data
//warning: without the attribute, gcc will inline this even if -Os is set
static void __attribute__ ((noinline)) rfm12_data(uint16_t d)
{
    18e2:	cf 93       	push	r28
    18e4:	c8 2f       	mov	r28, r24
	SS_ASSERT();
    18e6:	c2 98       	cbi	0x18, 2	; 24

	SPDR = d & 0xff;
	while(!(SPSR & (1<<SPIF)));

	#else
	spi_data(d >> 8   );
    18e8:	89 2f       	mov	r24, r25
    18ea:	eb df       	rcall	.-42     	; 0x18c2 <spi_data>
	spi_data(d &  0xff);
    18ec:	8c 2f       	mov	r24, r28
    18ee:	e9 df       	rcall	.-46     	; 0x18c2 <spi_data>
	#endif
	SS_RELEASE();
    18f0:	c2 9a       	sbi	0x18, 2	; 24
}
    18f2:	cf 91       	pop	r28
    18f4:	08 95       	ret

000018f6 <rfm12_data_inline>:


/* @description inline version of rfm12_data for use in interrupt
 */
static void rfm12_data_inline(uint8_t cmd, uint8_t d)
{
    18f6:	cf 93       	push	r28
    18f8:	df 93       	push	r29
    18fa:	1f 92       	push	r1
    18fc:	cd b7       	in	r28, 0x3d	; 61
    18fe:	de b7       	in	r29, 0x3e	; 62
	SS_ASSERT();
    1900:	c2 98       	cbi	0x18, 2	; 24

	SPDR = d;
	while(!(SPSR & (1<<SPIF)));

	#else
	spi_data( cmd );
    1902:	69 83       	std	Y+1, r22	; 0x01
    1904:	de df       	rcall	.-68     	; 0x18c2 <spi_data>
	spi_data( d   );
    1906:	69 81       	ldd	r22, Y+1	; 0x01
    1908:	86 2f       	mov	r24, r22
    190a:	db df       	rcall	.-74     	; 0x18c2 <spi_data>
	#endif
	SS_RELEASE();
    190c:	c2 9a       	sbi	0x18, 2	; 24
}
    190e:	0f 90       	pop	r0
    1910:	df 91       	pop	r29
    1912:	cf 91       	pop	r28
    1914:	08 95       	ret

00001916 <rfm12_read_fifo_inline>:

/* @description inline function for reading the fifo
 */
static uint8_t rfm12_read_fifo_inline()
{
	SS_ASSERT();
    1916:	c2 98       	cbi	0x18, 2	; 24
	SS_RELEASE();
	return SPDR;

	#else
	uint8_t retval;
	spi_data( RFM12_CMD_READ >> 8 );
    1918:	80 eb       	ldi	r24, 0xB0	; 176
    191a:	d3 df       	rcall	.-90     	; 0x18c2 <spi_data>
	retval = spi_data( 0   );
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	d1 df       	rcall	.-94     	; 0x18c2 <spi_data>

	SS_RELEASE();
    1920:	c2 9a       	sbi	0x18, 2	; 24
	return retval;
	#endif
}
    1922:	08 95       	ret

00001924 <rfm12_read.constprop.0>:
}


//non-inlined version of rfm12_read
//warning: without the attribute, gcc will inline this even if -Os is set
static uint16_t __attribute__ ((noinline)) rfm12_read(uint16_t c)
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
{
	uint16_t retval;
	SS_ASSERT();
    1928:	c2 98       	cbi	0x18, 2	; 24
	SPDR = c & 0xff;
	while(!(SPSR & (1<<SPIF)));
	retval |= SPDR;

	#else
	retval =  spi_data(c >> 8   );
    192a:	80 e0       	ldi	r24, 0x00	; 0
    192c:	ca df       	rcall	.-108    	; 0x18c2 <spi_data>
    192e:	c8 2f       	mov	r28, r24
    1930:	d0 e0       	ldi	r29, 0x00	; 0
	retval <<= 8;
    1932:	dc 2f       	mov	r29, r28
    1934:	cc 27       	eor	r28, r28
	retval |= spi_data(c &  0xff);
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	c4 df       	rcall	.-120    	; 0x18c2 <spi_data>
	#endif
	SS_RELEASE();
    193a:	c2 9a       	sbi	0x18, 2	; 24
	return retval;
}
    193c:	9e 01       	movw	r18, r28
    193e:	28 2b       	or	r18, r24
    1940:	c9 01       	movw	r24, r18
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	08 95       	ret

00001948 <rfm12_poll>:
#if (RFM12_USE_POLLING)
void rfm12_poll(void)
#else
ISR(RFM12_INT_VECT, ISR_NOBLOCK)
#endif
{
    1948:	cf 93       	push	r28
	RFM12_INT_OFF();
	uint8_t status;
	
	PORTD ^= _BV(PD5);
    194a:	92 b3       	in	r25, 0x12	; 18
    194c:	20 e2       	ldi	r18, 0x20	; 32
    194e:	92 27       	eor	r25, r18
    1950:	92 bb       	out	0x12, r25	; 18
/* @description reads the upper 8 bits of the status
 * register (the interrupt flags)
 */
static uint8_t rfm12_read_int_flags_inline()
{
	SS_ASSERT();
    1952:	c2 98       	cbi	0x18, 2	; 24
	SS_RELEASE();
	return SPDR;

	#else
	unsigned char x, d=d;
	PORT_MOSI &= ~(1<<BIT_MOSI);
    1954:	c3 98       	cbi	0x18, 3	; 24
    1956:	98 e0       	ldi	r25, 0x08	; 8
	for(x=0;x<8;x++){
		PORT_SCK |= (1<<BIT_SCK);
    1958:	c5 9a       	sbi	0x18, 5	; 24
		d<<=1;
    195a:	88 0f       	add	r24, r24
		if(PIN_MISO & (1<<BIT_MISO)){
    195c:	b4 99       	sbic	0x16, 4	; 22
			d|=1;
    195e:	81 60       	ori	r24, 0x01	; 1
		}
		PORT_SCK &= ~(1<<BIT_SCK);
    1960:	c5 98       	cbi	0x18, 5	; 24
    1962:	91 50       	subi	r25, 0x01	; 1
	return SPDR;

	#else
	unsigned char x, d=d;
	PORT_MOSI &= ~(1<<BIT_MOSI);
	for(x=0;x<8;x++){
    1964:	c9 f7       	brne	.-14     	; 0x1958 <rfm12_poll+0x10>
		if(PIN_MISO & (1<<BIT_MISO)){
			d|=1;
		}
		PORT_SCK &= ~(1<<BIT_SCK);
	}
	SS_RELEASE();
    1966:	c2 9a       	sbi	0x18, 2	; 24
		rfm12_data(ctrl.pwrmgt_shadow);
	}
	#endif /* RFM12_USE_WAKEUP_TIMER */

	//check if the fifo interrupt occurred
	if(!(status & (RFM12_STATUS_FFIT>>8)))
    1968:	87 ff       	sbrs	r24, 7
    196a:	75 c0       	rjmp	.+234    	; 0x1a56 <rfm12_poll+0x10e>
		goto END;

	//see what we have to do (start rx, rx or tx)
	switch(ctrl.rfm12_state)
    196c:	80 91 62 00 	lds	r24, 0x0062
    1970:	81 30       	cpi	r24, 0x01	; 1
    1972:	f1 f0       	breq	.+60     	; 0x19b0 <rfm12_poll+0x68>
    1974:	20 f0       	brcs	.+8      	; 0x197e <rfm12_poll+0x36>
    1976:	82 30       	cpi	r24, 0x02	; 2
    1978:	09 f4       	brne	.+2      	; 0x197c <rfm12_poll+0x34>
    197a:	4c c0       	rjmp	.+152    	; 0x1a14 <rfm12_poll+0xcc>
    197c:	63 c0       	rjmp	.+198    	; 0x1a44 <rfm12_poll+0xfc>
	{
		case STATE_RX_IDLE:
			//if receive mode is not disabled (default)
			#if !(RFM12_TRANSMIT_ONLY)
				//init the bytecounter - remember, we will read the length byte, so this must be 1
				ctrl.bytecount = 1;
    197e:	c1 e0       	ldi	r28, 0x01	; 1
    1980:	c0 93 65 00 	sts	0x0065, r28

				//read the length byte,  and write it to the checksum
				//remember, the first byte is the length byte
				checksum = rfm12_read_fifo_inline();
    1984:	c8 df       	rcall	.-112    	; 0x1916 <rfm12_read_fifo_inline>
    1986:	80 93 61 00 	sts	0x0061, r24

				//add the packet overhead and store it into a working variable
				ctrl.num_bytes = checksum + PACKET_OVERHEAD;
    198a:	93 e0       	ldi	r25, 0x03	; 3
    198c:	98 0f       	add	r25, r24
    198e:	90 93 64 00 	sts	0x0064, r25
					uart_putc(checksum);
				#endif

				//see whether our buffer is free
				//FIXME: put this into global statekeeping struct, the free state can be set by the function which pulls the packet, i guess
				if(rf_rx_buffers[ctrl.buffer_in_num].status == STATUS_FREE)
    1992:	e0 91 66 00 	lds	r30, 0x0066
    1996:	2c e4       	ldi	r18, 0x4C	; 76
    1998:	e2 9f       	mul	r30, r18
    199a:	f0 01       	movw	r30, r0
    199c:	11 24       	eor	r1, r1
    199e:	e8 59       	subi	r30, 0x98	; 152
    19a0:	ff 4f       	sbci	r31, 0xFF	; 255
    19a2:	90 81       	ld	r25, Z
    19a4:	91 11       	cpse	r25, r1
    19a6:	4e c0       	rjmp	.+156    	; 0x1a44 <rfm12_poll+0xfc>
				{
					//the current receive buffer is empty, so we start receiving
					ctrl.rfm12_state = STATE_RX_ACTIVE;
    19a8:	c0 93 62 00 	sts	0x0062, r28

					//store the received length into the packet buffer
					//FIXME:  why the hell do we need this?!
					//in principle, the length is stored alongside with the buffer.. the only problem is, that the buffer might be cleared during reception
					rf_rx_buffers[ctrl.buffer_in_num].len = checksum;
    19ac:	81 83       	std	Z+1, r24	; 0x01

					//end the interrupt without resetting the fifo
					goto END;
    19ae:	53 c0       	rjmp	.+166    	; 0x1a56 <rfm12_poll+0x10e>

		case STATE_RX_ACTIVE:
			//if receive mode is not disabled (default)
			#if !(RFM12_TRANSMIT_ONLY)
				//check if transmission is complete
				if(ctrl.bytecount < ctrl.num_bytes)
    19b0:	20 91 65 00 	lds	r18, 0x0065
    19b4:	90 91 64 00 	lds	r25, 0x0064
    19b8:	29 17       	cp	r18, r25
    19ba:	f0 f4       	brcc	.+60     	; 0x19f8 <rfm12_poll+0xb0>
				{
					uint8_t data;

					//read a byte
					data = rfm12_read_fifo_inline();
    19bc:	ac df       	rcall	.-168    	; 0x1916 <rfm12_read_fifo_inline>
						uart_putc(data);
					#endif

					//xor the remaining bytes onto the checksum
					//note: only the header will be effectively checked
					checksum ^= data;
    19be:	20 91 61 00 	lds	r18, 0x0061
    19c2:	28 27       	eor	r18, r24
    19c4:	20 93 61 00 	sts	0x0061, r18

					//put next byte into buffer, if there is enough space
					if(ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3))
    19c8:	90 91 65 00 	lds	r25, 0x0065
    19cc:	9b 34       	cpi	r25, 0x4B	; 75
    19ce:	20 f0       	brcs	.+8      	; 0x19d8 <rfm12_poll+0x90>
						//if the checksum does not match, reset the fifo
						break;
					}

					//increment bytecount
					ctrl.bytecount++;
    19d0:	9f 5f       	subi	r25, 0xFF	; 255
    19d2:	90 93 65 00 	sts	0x0065, r25

					//end the interrupt without resetting the fifo
					goto END;
    19d6:	3f c0       	rjmp	.+126    	; 0x1a56 <rfm12_poll+0x10e>

					//put next byte into buffer, if there is enough space
					if(ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3))
					{
						//hackhack: begin writing to struct at offsetof len
						(& rf_rx_buffers[ctrl.buffer_in_num].len)[ctrl.bytecount] = data;
    19d8:	e0 91 66 00 	lds	r30, 0x0066
    19dc:	3c e4       	ldi	r19, 0x4C	; 76
    19de:	e3 9f       	mul	r30, r19
    19e0:	f0 01       	movw	r30, r0
    19e2:	11 24       	eor	r1, r1
    19e4:	e7 59       	subi	r30, 0x97	; 151
    19e6:	ff 4f       	sbci	r31, 0xFF	; 255
    19e8:	e9 0f       	add	r30, r25
    19ea:	f1 1d       	adc	r31, r1
    19ec:	80 83       	st	Z, r24
					}

					//check header against checksum
					if (ctrl.bytecount == 2 && checksum != 0xff)
    19ee:	92 30       	cpi	r25, 0x02	; 2
    19f0:	79 f7       	brne	.-34     	; 0x19d0 <rfm12_poll+0x88>
    19f2:	2f 3f       	cpi	r18, 0xFF	; 255
    19f4:	39 f5       	brne	.+78     	; 0x1a44 <rfm12_poll+0xfc>
    19f6:	ec cf       	rjmp	.-40     	; 0x19d0 <rfm12_poll+0x88>
				#if RFM12_UART_DEBUG >= 2
					uart_putc('D');
				#endif

				//indicate that the buffer is ready to be used
				rf_rx_buffers[ctrl.buffer_in_num].status = STATUS_COMPLETE;
    19f8:	90 91 66 00 	lds	r25, 0x0066
    19fc:	2c e4       	ldi	r18, 0x4C	; 76
    19fe:	92 9f       	mul	r25, r18
    1a00:	f0 01       	movw	r30, r0
    1a02:	11 24       	eor	r1, r1
    1a04:	e8 59       	subi	r30, 0x98	; 152
    1a06:	ff 4f       	sbci	r31, 0xFF	; 255
    1a08:	22 e0       	ldi	r18, 0x02	; 2
    1a0a:	20 83       	st	Z, r18

				//switch to other buffer
				ctrl.buffer_in_num ^= 1;
    1a0c:	89 27       	eor	r24, r25
    1a0e:	80 93 66 00 	sts	0x0066, r24
			#endif /* !(RFM12_TRANSMIT_ONLY) */
			break;
    1a12:	18 c0       	rjmp	.+48     	; 0x1a44 <rfm12_poll+0xfc>
			//debug
			#if RFM12_UART_DEBUG >= 2
				uart_putc('T');
			#endif

			if(ctrl.bytecount < ctrl.num_bytes)
    1a14:	e0 91 65 00 	lds	r30, 0x0065
    1a18:	80 91 64 00 	lds	r24, 0x0064
    1a1c:	e8 17       	cp	r30, r24
    1a1e:	50 f4       	brcc	.+20     	; 0x1a34 <rfm12_poll+0xec>
			{
				//load the next byte from our buffer struct.
				rfm12_data_inline( (RFM12_CMD_TX>>8), rf_tx_buffer.sync[ctrl.bytecount++]);
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	8e 0f       	add	r24, r30
    1a24:	80 93 65 00 	sts	0x0065, r24
    1a28:	f0 e0       	ldi	r31, 0x00	; 0
    1a2a:	e0 50       	subi	r30, 0x00	; 0
    1a2c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a2e:	60 81       	ld	r22, Z
    1a30:	88 eb       	ldi	r24, 0xB8	; 184
    1a32:	0f c0       	rjmp	.+30     	; 0x1a52 <rfm12_poll+0x10a>

			/* if we're here, we're finished transmitting the bytes */
			/* the fifo will be reset at the end of the function */

			//flag the buffer as free again
			ctrl.txstate = STATUS_FREE;
    1a34:	10 92 63 00 	sts	0x0063, r1

			//turn off the transmitter and enable receiver
			//the receiver is not enabled in transmit only mode
			//if the wakeup timer is used, this will re-enable the wakeup timer bit
			//the magic is done via defines
			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_RECEIVE);
    1a38:	81 e8       	ldi	r24, 0x81	; 129
    1a3a:	92 e8       	ldi	r25, 0x82	; 130
    1a3c:	52 df       	rcall	.-348    	; 0x18e2 <rfm12_data>

			//load a dummy byte to clear int status
			rfm12_data_inline( (RFM12_CMD_TX>>8), 0xaa);
    1a3e:	6a ea       	ldi	r22, 0xAA	; 170
    1a40:	88 eb       	ldi	r24, 0xB8	; 184
    1a42:	59 df       	rcall	.-334    	; 0x18f6 <rfm12_data_inline>
			break;
	}

	//set the state machine to idle
	ctrl.rfm12_state = STATE_RX_IDLE;
    1a44:	10 92 62 00 	sts	0x0062, r1

	//reset the receiver fifo, if receive mode is not disabled (default)
	#if !(RFM12_TRANSMIT_ONLY)
		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, CLEAR_FIFO_INLINE);
    1a48:	61 e8       	ldi	r22, 0x81	; 129
    1a4a:	8a ec       	ldi	r24, 0xCA	; 202
    1a4c:	54 df       	rcall	.-344    	; 0x18f6 <rfm12_data_inline>
		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, ACCEPT_DATA_INLINE);
    1a4e:	63 e8       	ldi	r22, 0x83	; 131
    1a50:	8a ec       	ldi	r24, 0xCA	; 202
	#endif /* !(RFM12_TRANSMIT_ONLY) */

	END:
	//turn the int back on
	RFM12_INT_ON();
}
    1a52:	cf 91       	pop	r28
	ctrl.rfm12_state = STATE_RX_IDLE;

	//reset the receiver fifo, if receive mode is not disabled (default)
	#if !(RFM12_TRANSMIT_ONLY)
		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, CLEAR_FIFO_INLINE);
		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, ACCEPT_DATA_INLINE);
    1a54:	50 cf       	rjmp	.-352    	; 0x18f6 <rfm12_data_inline>
	#endif /* !(RFM12_TRANSMIT_ONLY) */

	END:
	//turn the int back on
	RFM12_INT_ON();
}
    1a56:	cf 91       	pop	r28
    1a58:	08 95       	ret

00001a5a <rfm12_tick>:
			oldstate = state;
		}
	#endif

	//don't disturb RFM12 if transmitting or receiving
	if(ctrl.rfm12_state != STATE_RX_IDLE)
    1a5a:	80 91 62 00 	lds	r24, 0x0062
    1a5e:	81 11       	cpse	r24, r1
    1a60:	1a c0       	rjmp	.+52     	; 0x1a96 <rfm12_tick+0x3c>
		//reset the channel free count for the next decrement (during the next call..)
		channel_free_count = 1;
	#endif

	//do we have something to transmit?
	if(ctrl.txstate == STATUS_OCCUPIED)
    1a62:	80 91 63 00 	lds	r24, 0x0063
    1a66:	81 30       	cpi	r24, 0x01	; 1
    1a68:	b1 f4       	brne	.+44     	; 0x1a96 <rfm12_tick+0x3c>
		//anyhow, we MUST transmit at some point...
		RFM12_INT_OFF();

		//disable receiver - if you don't do this, tx packets will get lost
		//as the fifo seems to be in use by the receiver
		rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT);
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	92 e8       	ldi	r25, 0x82	; 130
    1a6e:	39 df       	rcall	.-398    	; 0x18e2 <rfm12_data>

		//calculate number of bytes to be sent by ISR
		//2 sync bytes + len byte + type byte + checksum + message length + 1 dummy byte
		ctrl.num_bytes = rf_tx_buffer.len + 6;
    1a70:	80 91 02 01 	lds	r24, 0x0102
    1a74:	8a 5f       	subi	r24, 0xFA	; 250
    1a76:	80 93 64 00 	sts	0x0064, r24

		//reset byte sent counter
		ctrl.bytecount = 0;
    1a7a:	10 92 65 00 	sts	0x0065, r1

		//set mode for interrupt handler
		ctrl.rfm12_state = STATE_TX;
    1a7e:	82 e0       	ldi	r24, 0x02	; 2
    1a80:	80 93 62 00 	sts	0x0062, r24
		#endif /* RFM12_USE_WAKEUP_TIMER */

		//fill 2byte 0xAA preamble into data register
		//the preamble helps the receivers AFC circuit to lock onto the exact frequency
		//(hint: the tx FIFO [if el is enabled] is two staged, so we can safely write 2 bytes before starting)
		rfm12_data(RFM12_CMD_TX | PREAMBLE);
    1a84:	8a ea       	ldi	r24, 0xAA	; 170
    1a86:	98 eb       	ldi	r25, 0xB8	; 184
    1a88:	2c df       	rcall	.-424    	; 0x18e2 <rfm12_data>
		rfm12_data(RFM12_CMD_TX | PREAMBLE);
    1a8a:	8a ea       	ldi	r24, 0xAA	; 170
    1a8c:	98 eb       	ldi	r25, 0xB8	; 184
    1a8e:	29 df       	rcall	.-430    	; 0x18e2 <rfm12_data>

		//set ET in power register to enable transmission (hint: TX starts now)
		rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT | RFM12_PWRMGT_ET);
    1a90:	81 e2       	ldi	r24, 0x21	; 33
    1a92:	92 e8       	ldi	r25, 0x82	; 130
    1a94:	26 cf       	rjmp	.-436    	; 0x18e2 <rfm12_data>
    1a96:	08 95       	ret

00001a98 <rfm12_start_tx>:
uint8_t
#endif
rfm12_start_tx(uint8_t type, uint8_t length)
{
	//exit if the buffer isn't free
	if(ctrl.txstate != STATUS_FREE)
    1a98:	90 91 63 00 	lds	r25, 0x0063
    1a9c:	91 11       	cpse	r25, r1
    1a9e:	0d c0       	rjmp	.+26     	; 0x1aba <rfm12_start_tx+0x22>
		return TXRETURN(RFM12_TX_OCCUPIED);

	//write airlab header to buffer
	rf_tx_buffer.len = length;
    1aa0:	60 93 02 01 	sts	0x0102, r22
	rf_tx_buffer.type = type;
    1aa4:	80 93 03 01 	sts	0x0103, r24
	rf_tx_buffer.checksum = length ^ type ^ 0xff;
    1aa8:	86 27       	eor	r24, r22
    1aaa:	80 95       	com	r24
    1aac:	80 93 04 01 	sts	0x0104, r24

	//schedule packet for transmission
	ctrl.txstate = STATUS_OCCUPIED;
    1ab0:	81 e0       	ldi	r24, 0x01	; 1
    1ab2:	80 93 63 00 	sts	0x0063, r24

	return TXRETURN(RFM12_TX_ENQUEUED);
    1ab6:	80 e8       	ldi	r24, 0x80	; 128
    1ab8:	08 95       	ret
#endif
rfm12_start_tx(uint8_t type, uint8_t length)
{
	//exit if the buffer isn't free
	if(ctrl.txstate != STATUS_FREE)
		return TXRETURN(RFM12_TX_OCCUPIED);
    1aba:	83 e0       	ldi	r24, 0x03	; 3

	//schedule packet for transmission
	ctrl.txstate = STATUS_OCCUPIED;

	return TXRETURN(RFM12_TX_ENQUEUED);
}
    1abc:	08 95       	ret

00001abe <rfm12_tx>:
	void
	#else
	uint8_t
	#endif
	rfm12_tx(uint8_t len, uint8_t type, uint8_t *data)
	{
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	c8 2f       	mov	r28, r24
    1ac4:	d6 2f       	mov	r29, r22
    1ac6:	ba 01       	movw	r22, r20
		#if RFM12_UART_DEBUG
			uart_putstr ("sending packet\r\n");
		#endif

		if (len > RFM12_TX_BUFFER_SIZE) return TXRETURN(RFM12_TX_ERROR);
    1ac8:	8b 33       	cpi	r24, 0x3B	; 59
    1aca:	70 f4       	brcc	.+28     	; 0x1ae8 <rfm12_tx+0x2a>

		//exit if the buffer isn't free
		if(ctrl.txstate != STATUS_FREE)
    1acc:	80 91 63 00 	lds	r24, 0x0063
    1ad0:	81 11       	cpse	r24, r1
    1ad2:	0c c0       	rjmp	.+24     	; 0x1aec <rfm12_tx+0x2e>
			return TXRETURN(RFM12_TX_OCCUPIED);

		memcpy ( rf_tx_buffer.buffer, data, len );
    1ad4:	4c 2f       	mov	r20, r28
    1ad6:	50 e0       	ldi	r21, 0x00	; 0
    1ad8:	85 e0       	ldi	r24, 0x05	; 5
    1ada:	91 e0       	ldi	r25, 0x01	; 1
    1adc:	9a d0       	rcall	.+308    	; 0x1c12 <memcpy>

		#if (!(RFM12_NORETURNS))
		return rfm12_start_tx (type, len);
    1ade:	6c 2f       	mov	r22, r28
    1ae0:	8d 2f       	mov	r24, r29
		#else
		rfm12_start_tx (type, len);
		#endif
	}
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
			return TXRETURN(RFM12_TX_OCCUPIED);

		memcpy ( rf_tx_buffer.buffer, data, len );

		#if (!(RFM12_NORETURNS))
		return rfm12_start_tx (type, len);
    1ae6:	d8 cf       	rjmp	.-80     	; 0x1a98 <rfm12_start_tx>
	{
		#if RFM12_UART_DEBUG
			uart_putstr ("sending packet\r\n");
		#endif

		if (len > RFM12_TX_BUFFER_SIZE) return TXRETURN(RFM12_TX_ERROR);
    1ae8:	82 e0       	ldi	r24, 0x02	; 2
    1aea:	01 c0       	rjmp	.+2      	; 0x1aee <rfm12_tx+0x30>

		//exit if the buffer isn't free
		if(ctrl.txstate != STATUS_FREE)
			return TXRETURN(RFM12_TX_OCCUPIED);
    1aec:	83 e0       	ldi	r24, 0x03	; 3
		#if (!(RFM12_NORETURNS))
		return rfm12_start_tx (type, len);
		#else
		rfm12_start_tx (type, len);
		#endif
	}
    1aee:	df 91       	pop	r29
    1af0:	cf 91       	pop	r28
    1af2:	08 95       	ret

00001af4 <rfm12_rx_clear>:
	*/
	//warning: without the attribute, gcc will inline this even if -Os is set
	void __attribute__((noinline)) rfm12_rx_clear(void)
	{
			//mark the current buffer as empty
			rf_rx_buffers[ctrl.buffer_out_num].status = STATUS_FREE;
    1af4:	a7 e6       	ldi	r26, 0x67	; 103
    1af6:	b0 e0       	ldi	r27, 0x00	; 0
    1af8:	9c 91       	ld	r25, X
    1afa:	8c e4       	ldi	r24, 0x4C	; 76
    1afc:	98 9f       	mul	r25, r24
    1afe:	f0 01       	movw	r30, r0
    1b00:	11 24       	eor	r1, r1
    1b02:	e8 59       	subi	r30, 0x98	; 152
    1b04:	ff 4f       	sbci	r31, 0xFF	; 255
    1b06:	10 82       	st	Z, r1

			//switch to the other buffer
			ctrl.buffer_out_num ^= 1;
    1b08:	81 e0       	ldi	r24, 0x01	; 1
    1b0a:	89 27       	eor	r24, r25
    1b0c:	8c 93       	st	X, r24
    1b0e:	08 95       	ret

00001b10 <rfm12_init>:
    1b10:	c2 9a       	sbi	0x18, 2	; 24
    1b12:	ba 9a       	sbi	0x17, 2	; 23
    1b14:	bb 9a       	sbi	0x17, 3	; 23
    1b16:	bd 9a       	sbi	0x17, 5	; 23
    1b18:	c2 9a       	sbi	0x18, 2	; 24
    1b1a:	ba 9a       	sbi	0x17, 2	; 23
    1b1c:	bc 98       	cbi	0x17, 4	; 23
    1b1e:	87 ed       	ldi	r24, 0xD7	; 215
    1b20:	90 e8       	ldi	r25, 0x80	; 128
    1b22:	df de       	rcall	.-578    	; 0x18e2 <rfm12_data>
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	92 e8       	ldi	r25, 0x82	; 130
    1b28:	dc de       	rcall	.-584    	; 0x18e2 <rfm12_data>
    1b2a:	80 e2       	ldi	r24, 0x20	; 32
    1b2c:	96 ea       	ldi	r25, 0xA6	; 166
    1b2e:	d9 de       	rcall	.-590    	; 0x18e2 <rfm12_data>
    1b30:	83 e2       	ldi	r24, 0x23	; 35
    1b32:	96 ec       	ldi	r25, 0xC6	; 198
    1b34:	d6 de       	rcall	.-596    	; 0x18e2 <rfm12_data>
    1b36:	8c e2       	ldi	r24, 0x2C	; 44
    1b38:	94 e9       	ldi	r25, 0x94	; 148
    1b3a:	d3 de       	rcall	.-602    	; 0x18e2 <rfm12_data>
    1b3c:	8b ea       	ldi	r24, 0xAB	; 171
    1b3e:	92 ec       	ldi	r25, 0xC2	; 194
    1b40:	d0 de       	rcall	.-608    	; 0x18e2 <rfm12_data>
    1b42:	81 e8       	ldi	r24, 0x81	; 129
    1b44:	9a ec       	ldi	r25, 0xCA	; 202
    1b46:	cd de       	rcall	.-614    	; 0x18e2 <rfm12_data>
    1b48:	87 ef       	ldi	r24, 0xF7	; 247
    1b4a:	94 ec       	ldi	r25, 0xC4	; 196
    1b4c:	ca de       	rcall	.-620    	; 0x18e2 <rfm12_data>
    1b4e:	80 e7       	ldi	r24, 0x70	; 112
    1b50:	98 e9       	ldi	r25, 0x98	; 152
    1b52:	c7 de       	rcall	.-626    	; 0x18e2 <rfm12_data>
    1b54:	80 e0       	ldi	r24, 0x00	; 0
    1b56:	98 ec       	ldi	r25, 0xC8	; 200
    1b58:	c4 de       	rcall	.-632    	; 0x18e2 <rfm12_data>
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	90 ee       	ldi	r25, 0xE0	; 224
    1b5e:	c1 de       	rcall	.-638    	; 0x18e2 <rfm12_data>
    1b60:	8d e2       	ldi	r24, 0x2D	; 45
    1b62:	80 93 00 01 	sts	0x0100, r24
    1b66:	84 ed       	ldi	r24, 0xD4	; 212
    1b68:	80 93 01 01 	sts	0x0101, r24
    1b6c:	10 92 66 00 	sts	0x0066, r1
    1b70:	10 92 67 00 	sts	0x0067, r1
    1b74:	81 e8       	ldi	r24, 0x81	; 129
    1b76:	92 e8       	ldi	r25, 0x82	; 130
    1b78:	b4 de       	rcall	.-664    	; 0x18e2 <rfm12_data>
    1b7a:	85 b7       	in	r24, 0x35	; 53
    1b7c:	82 60       	ori	r24, 0x02	; 2
    1b7e:	85 bf       	out	0x35, r24	; 53
    1b80:	d1 de       	rcall	.-606    	; 0x1924 <rfm12_read.constprop.0>
    1b82:	8a b7       	in	r24, 0x3a	; 58
    1b84:	80 64       	ori	r24, 0x40	; 64
    1b86:	8a bf       	out	0x3a, r24	; 58
    1b88:	81 e8       	ldi	r24, 0x81	; 129
    1b8a:	9a ec       	ldi	r25, 0xCA	; 202
    1b8c:	aa de       	rcall	.-684    	; 0x18e2 <rfm12_data>
    1b8e:	83 e8       	ldi	r24, 0x83	; 131
    1b90:	9a ec       	ldi	r25, 0xCA	; 202
    1b92:	a7 ce       	rjmp	.-690    	; 0x18e2 <rfm12_data>

00001b94 <main>:
}

#define TLED() PORTD ^= (_BV(PD5) | _BV(PD6))
int main (void)
//int __attribute__ ((naked)) main (void)
{
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	cd b7       	in	r28, 0x3d	; 61
    1b9a:	de b7       	in	r29, 0x3e	; 62
    1b9c:	a0 97       	sbiw	r28, 0x20	; 32
    1b9e:	0f b6       	in	r0, 0x3f	; 63
    1ba0:	f8 94       	cli
    1ba2:	de bf       	out	0x3e, r29	; 62
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	cd bf       	out	0x3d, r28	; 61
	uint32_t pagenum = 0;
	uint16_t crcsum = 0;
	nl_flashcmd *mycmd;
	
	/* pollin board */
	DDRD |= _BV(PD7) | _BV(PD5) | _BV(PD6);
    1ba8:	81 b3       	in	r24, 0x11	; 17
    1baa:	80 6e       	ori	r24, 0xE0	; 224
    1bac:	81 bb       	out	0x11, r24	; 17
	PORTD |= _BV(PD7); // FSK
    1bae:	97 9a       	sbi	0x12, 7	; 18

	/* read address */
	for (i=0;i<NL_ADDRESSSIZE;i++)
	{
		myaddress[i] =
			eeprom_read_byte (
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	37 d0       	rcall	.+110    	; 0x1c24 <__eerd_byte_m8>
	#endif

	/* read address */
	for (i=0;i<NL_ADDRESSSIZE;i++)
	{
		myaddress[i] =
    1bb6:	80 93 60 00 	sts	0x0060, r24
			eeprom_read_byte (
				(uint8_t *) (((uint8_t) i) + ((uint8_t) NL_ADDRESSPOS)));
	}

	/* move interrupt vector table to bootloader section */
	cli();
    1bba:	f8 94       	cli

	#if (MCU == atmega328p) || (MCU == atmega168)
	MCUCR = (1<<IVCE);
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	85 bf       	out	0x35, r24	; 53
	MCUCR = (1<<IVSEL);
    1bc0:	82 e0       	ldi	r24, 0x02	; 2
    1bc2:	85 bf       	out	0x35, r24	; 53
	#else
	GICR = (1<<IVCE);
	GICR = (1<<IVSEL);
	#endif
	rfm12_init();
    1bc4:	a5 df       	rcall	.-182    	; 0x1b10 <rfm12_init>
	rfm12_init();
    1bc6:	a4 df       	rcall	.-184    	; 0x1b10 <rfm12_init>
	rfm12_init();
    1bc8:	a3 df       	rcall	.-186    	; 0x1b10 <rfm12_init>
	rfm12_init();
    1bca:	a2 df       	rcall	.-188    	; 0x1b10 <rfm12_init>
	sei();
    1bcc:	78 94       	sei
    1bce:	c1 2c       	mov	r12, r1
    1bd0:	d1 2c       	mov	r13, r1
    1bd2:	76 01       	movw	r14, r12
    1bd4:	c3 94       	inc	r12
	
	rfm12_start_tx (NL_ADDRESSSIZE + 2 + in_len, NL_PACKETTYPE);

	#else
	uint8_t txbuf[32];
	txbuf[0] = in_type;
    1bd6:	12 e0       	ldi	r17, 0x02	; 2
		i++;

		if ((i & 0xffff) == 0)
		{
			nl_tx_packet (NLPROTO_ERROR, 0, mypage);
			TLED();
    1bd8:	00 e6       	ldi	r16, 0x60	; 96
	rfm12_init();
	sei();
	
	while (2)
	{
		i++;
    1bda:	8f ef       	ldi	r24, 0xFF	; 255
    1bdc:	c8 1a       	sub	r12, r24
    1bde:	d8 0a       	sbc	r13, r24
    1be0:	e8 0a       	sbc	r14, r24
    1be2:	f8 0a       	sbc	r15, r24

		if ((i & 0xffff) == 0)
    1be4:	d7 01       	movw	r26, r14
    1be6:	c6 01       	movw	r24, r12
    1be8:	aa 27       	eor	r26, r26
    1bea:	bb 27       	eor	r27, r27
    1bec:	89 2b       	or	r24, r25
    1bee:	8a 2b       	or	r24, r26
    1bf0:	8b 2b       	or	r24, r27
    1bf2:	69 f4       	brne	.+26     	; 0x1c0e <main+0x7a>
	
	rfm12_start_tx (NL_ADDRESSSIZE + 2 + in_len, NL_PACKETTYPE);

	#else
	uint8_t txbuf[32];
	txbuf[0] = in_type;
    1bf4:	19 83       	std	Y+1, r17	; 0x01
	txbuf[1] = myaddress[0];
    1bf6:	80 91 60 00 	lds	r24, 0x0060
    1bfa:	8a 83       	std	Y+2, r24	; 0x02
	#if NL_ADDRESSSIZE == 2
	txbuf[2] = myaddress[1];
	#endif
	memcpy (&txbuf[NL_ADDRESSSIZE+1], in_payload, in_len);

	rfm12_tx (NL_ADDRESSSIZE + 1 + in_len, NL_PACKETTYPE, txbuf);
    1bfc:	ae 01       	movw	r20, r28
    1bfe:	4f 5f       	subi	r20, 0xFF	; 255
    1c00:	5f 4f       	sbci	r21, 0xFF	; 255
    1c02:	60 ee       	ldi	r22, 0xE0	; 224
    1c04:	82 e0       	ldi	r24, 0x02	; 2
    1c06:	5b df       	rcall	.-330    	; 0x1abe <rfm12_tx>
		i++;

		if ((i & 0xffff) == 0)
		{
			nl_tx_packet (NLPROTO_ERROR, 0, mypage);
			TLED();
    1c08:	82 b3       	in	r24, 0x12	; 18
    1c0a:	80 27       	eor	r24, r16
    1c0c:	82 bb       	out	0x12, r24	; 18
		}
		rfm12_tick();
    1c0e:	25 df       	rcall	.-438    	; 0x1a5a <rfm12_tick>
	}
    1c10:	e4 cf       	rjmp	.-56     	; 0x1bda <main+0x46>

00001c12 <memcpy>:
    1c12:	fb 01       	movw	r30, r22
    1c14:	dc 01       	movw	r26, r24
    1c16:	02 c0       	rjmp	.+4      	; 0x1c1c <memcpy+0xa>
    1c18:	01 90       	ld	r0, Z+
    1c1a:	0d 92       	st	X+, r0
    1c1c:	41 50       	subi	r20, 0x01	; 1
    1c1e:	50 40       	sbci	r21, 0x00	; 0
    1c20:	d8 f7       	brcc	.-10     	; 0x1c18 <memcpy+0x6>
    1c22:	08 95       	ret

00001c24 <__eerd_byte_m8>:
    1c24:	e1 99       	sbic	0x1c, 1	; 28
    1c26:	fe cf       	rjmp	.-4      	; 0x1c24 <__eerd_byte_m8>
    1c28:	9f bb       	out	0x1f, r25	; 31
    1c2a:	8e bb       	out	0x1e, r24	; 30
    1c2c:	e0 9a       	sbi	0x1c, 0	; 28
    1c2e:	99 27       	eor	r25, r25
    1c30:	8d b3       	in	r24, 0x1d	; 29
    1c32:	08 95       	ret

00001c34 <_exit>:
    1c34:	f8 94       	cli

00001c36 <__stop_program>:
    1c36:	ff cf       	rjmp	.-2      	; 0x1c36 <__stop_program>
